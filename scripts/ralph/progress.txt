## Codebase Patterns
- Use `Command` type for CLI subcommands: `type Command func(cfg *config.Config, args []string) error`
- Store commands in a map for easy routing: `var commands = map[string]Command{...}`
- Config file is searched in current directory and parent directories (findConfigFile)
- Use runtime.GOOS for OS-specific behavior (not os.Getenv)
- Use `internal/` packages for private implementation (e.g., internal/tmux, internal/config)
- Runner pattern for external tool wrappers: create a Runner struct with methods for operations
- Always skip tests if external dependencies (like tmux) are not available in PATH
- Native messaging protocol: 4-byte length prefix (native endian) + JSON body
- Use `binary.NativeEndian` for native byte order in native messaging protocol
- Browser extensions: Use chrome.runtime.sendMessage for content-to-background communication
- Browser extensions: Need separate manifests for Chrome (MV3) and Firefox (MV2)
- Browser extensions: Content scripts inject in isolated world but can access page DOM
- Browser extensions: chrome.runtime.onMessage.addListener for receiving messages (return true for async)
- Browser extensions: Wrap console methods to preserve original behavior + capture logs

## 2026-02-10 - US-002 - CLI scaffold with up/down/status/open commands
- What was implemented:
  - Refactored main.go to use a Command type and command map pattern
  - Implemented cmdUp, cmdDown, cmdStatus, cmdOpen, cmdHelp functions
  - Added findConfigFile() to search for devlog.yml in current and parent directories
  - Added usage string with help text
  - Commands now load config before executing (except help)
  - Added runtime.GOOS detection for cross-platform file manager opening
  
- Files changed:
  - cmd/devlog/main.go - complete refactor of CLI structure
  - prd.json - created with user stories
  - progress.txt - created with this progress

- **Learnings for future iterations:**
  - The command pattern with `type Command func(cfg *config.Config, args []string) error` works well for subcommands
  - Searching parent directories for config file is a nice UX touch
  - fmt.Fprintln with a string ending in newline causes vet warning - use fmt.Fprint instead
  - Use runtime.GOOS, not os.Getenv("GOOS") for OS detection
  - Commands are currently stubs - next stories (US-003+) will implement actual tmux integration

---

## 2026-02-10 - US-003 - Create tmux session with windows and panes
- What was implemented:
  - Created internal/tmux package with Runner type for tmux operations
  - Implemented CreateSession() to create tmux sessions with configured windows and panes
  - Implemented KillSession() to stop tmux sessions
  - Implemented GetSessionInfo() to retrieve session status and window info
  - Implemented SessionExists() to check if a session already exists
  - Commands are sent to panes with output redirected to log files using tee
  - Updated cmdUp, cmdDown, and cmdStatus to use the tmux package
  - Added comprehensive tests for all tmux operations

- Files changed:
  - internal/tmux/tmux.go - New tmux session management package
  - internal/tmux/tmux_test.go - Tests for tmux operations
  - cmd/devlog/main.go - Integrated tmux package into CLI commands
  - prd.json - Marked US-003 as passing
  - progress.txt - Added this progress entry

- **Learnings for future iterations:**
  - tmux window indices start from 1, not 0
  - tmux send-keys targets should use window names (e.g., `session:windowname`) not indices
  - After split-window, the new pane becomes the active pane
  - fmt.Sscanf doesn't support %[^|] pattern - use strings.Split instead
  - Use tee -a for log files to append output and display to terminal
  - Always check if tmux is available in PATH before running tests

---

## 2026-02-10 - US-004 - Stop tmux session and clean up
- What was implemented:
  - Enhanced KillSession() to gracefully terminate pane processes before killing session
  - Added getPaneIDs() helper to get all pane IDs in the session
  - Sends Ctrl+C to all panes first for graceful process termination
  - Sends a second Ctrl+C after brief wait for stubborn processes
  - Killing the session flushes and closes all log files automatically
  - Maintains error handling for non-existent sessions

- Files changed:
  - internal/tmux/tmux.go - Enhanced KillSession() with graceful shutdown
  - prd.json - Marked US-004 as passing
  - progress.txt - Added this progress entry

- **Learnings for future iterations:**
  - Use `tmux send-keys -t target C-c` to gracefully interrupt running processes
  - `tmux list-panes -t session -F "#{pane_id}"` gets all pane IDs for iteration
  - Sending Ctrl+C twice helps terminate stubborn processes
  - tmux pane IDs start with `%` (e.g., `%0`, `%1`)
  - Killing a session automatically closes all panes and flushes their output

---

## 2026-02-10 - US-005 - Show session status
- What was implemented:
  - Enhanced cmdStatus to show detailed pane information (pane ID, current command)
  - Added browser logging status showing URLs monitored, log file path, and filter levels
  - Enhanced GetSessionInfo() to retrieve pane details for each window
  - Added getWindowPanes() helper to get pane ID, index, and current command
  - Added log file existence status (exists/missing) for both tmux and browser logs
  - Shows "disabled" message when no browser URLs are configured

- Files changed:
  - internal/tmux/tmux.go - Added PaneInfo type, enhanced GetSessionInfo(), added getWindowPanes()
  - cmd/devlog/main.go - Enhanced cmdStatus with pane details and browser logging status
  - scripts/ralph/prd.json - Marked US-005 as passing
  - scripts/ralph/progress.txt - Added this progress entry

- **Learnings for future iterations:**
  - tmux list-panes -F "#{pane_id}|#{pane_index}|#{pane_current_command}" gets pane details
  - Use filepath.Join() to construct log file paths for cross-platform compatibility
  - os.Stat() can check if log files exist to show "exists"/"missing" status
  - Window panes are stored in WindowInfo.Panes for easy iteration in status display
  - Browser config has URLs, File, and Levels fields for complete status reporting

---

## 2026-02-10 - US-006 - Native messaging host for browser logs
- What was implemented:
  - Created internal/natmsg package for Native Messaging protocol handling
  - Created internal/logger package for browser log file writing with level filtering
  - Created cmd/devlog-host/main.go binary that runs as separate process
  - Protocol: reads 4-byte length prefix (native endian) + JSON from stdin
  - Messages formatted as: [TIMESTAMP] [LEVEL] [URL] source:line:column: message
  - Supports log level filtering (case-insensitive)
  - Sends acknowledgment responses back to browser
  - Comprehensive tests for both natmsg and logger packages

- Files changed:
  - internal/natmsg/natmsg.go - Native messaging protocol implementation
  - internal/natmsg/natmsg_test.go - Protocol tests
  - internal/logger/logger.go - Log file writing with filtering
  - internal/logger/logger_test.go - Logger tests
  - cmd/devlog-host/main.go - Native host binary entry point
  - scripts/ralph/prd.json - Marked US-006 as passing
  - scripts/ralph/progress.txt - Added this progress entry

- **Learnings for future iterations:**
  - Native Messaging protocol uses binary.NativeEndian for the 4-byte length prefix
  - Messages over 10MB are rejected as a sanity check
  - Log levels are case-insensitive for better UX
  - The host exits cleanly on EOF (browser closing connection)
  - io.ReadFull is needed to ensure complete reads of the length prefix and body
  - Use sync.Mutex in logger to handle concurrent writes from multiple browser tabs

 ---

## 2026-02-10 - US-007 - Browser extension manifest and content script
- What was implemented:
  - Created browser-extension directory with complete browser extension
  - Implemented Chrome Manifest V3 and Firefox Manifest V2 configurations
  - Created content_script.js to capture all console.* methods (log, info, warn, error, debug, trace)
  - Added uncaught error and unhandled promise rejection capture
  - Implemented background.js for native messaging connection management
  - Created popup UI (popup.html/popup.js) to show extension status
  - Added URL pattern matching for filtering which pages to log
  - Included native host manifest templates for Chrome and Firefox
  - Added comprehensive README with installation and development instructions

- Files changed:
  - browser-extension/manifest.json - Chrome Manifest V3
  - browser-extension/manifest-firefox.json - Firefox Manifest V2
  - browser-extension/background.js - Background script for native messaging
  - browser-extension/content_script.js - Console log capture script
  - browser-extension/popup.html - Extension popup UI
  - browser-extension/popup.js - Popup logic
  - browser-extension/com.devlog.host.json - Chrome native host manifest template
  - browser-extension/com.devlog.host.firefox.json - Firefox native host manifest template
  - browser-extension/icons/icon.svg - Extension icon
  - browser-extension/README.md - Installation and usage documentation
  - scripts/ralph/prd.json - Marked US-007 as passing
  - scripts/ralph/progress.txt - Added this progress entry

- **Learnings for future iterations:**
  - Content scripts inject into isolated world but can access page DOM
  - chrome.runtime.sendMessage is async and can reject if extension disconnects
  - URL patterns use simple wildcard matching (* for any characters)
  - Stack traces need parsing to extract source file, line, and column
  - Console methods must be wrapped to preserve original behavior + capture logs
  - Extensions need both manifest types for Chrome (MV3) and Firefox (MV2)
  - Native messaging requires manifest files in OS-specific directories
  - Service workers in MV3 are persistent but can be terminated; use onMessage for state
  - Content scripts can use chrome.runtime.onMessage to receive config updates

---
